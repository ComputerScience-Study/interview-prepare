**프로세스와 스레드의 차이는 무엇입니까?**

- 프로세스 : 메모리 상에서 실행중인 프로그램
    - 최소 하나의 스레드를 보유
    - 각각의 별도의 주소 공간을 독립적으로 할당받음(code, heap, stack)
    - 문제점
        - 프로세스 생성에 큰 오버헤드가 있음
        - 프로세스 컨텍스트 스위칭의 비효율성, 오버헤드가 큼
        - 프로세스 사이에 통신이 어려움
- 스레드 : 프로세스 내에서 실행되는 흐름 단위
    - stack만 따로 할당받고 나머지 영역은 스레드 끼리 공유
    - 출현 목적
        - 프로세스보다 크기가 작은 실행 단위 필요
        - 프로세스의 생성 및 소멸에 따른 오버헤드 감소
        - 빠른 컨텍스트 스위칭
        - 프로세스들의 통신 시간, 방법 어려움 해소
    - 주소 공간
        - 하나의 스레드가 동작하기 위해 총 6개의 공간이 있음
            - 사적공간
                - 스레드 코드 공간, 스레드 전용 전역변수 공간, 스택 공간
            - 공유공간
                - 데이터 공간, 힙 공간
            - 커널스택
- 멀티 프로세스 vs 멀티 스레드

**크롬 탭 하나는 프로세스인가요? 스레드인가요?**

- 크롬의 각 탭은 프로세스
    - 제일 위의 프로세스가 모든 프로세스의 부모 프로세스
        
        ```
        # 명령어로 확인 가능
        wmic process get Caption, ParentProcessId, ProcessId | find /i "chrome"
        ```
        
        - PPID는 부모의 PID를 의미
    - 각 프로세스는 IPC(Inter Process Communication)로 소통
- 왜 Process일까?
    - 멀티 스레드는 성능면에서는 유리하지만 안정성과 보안 등에서 취약함

**가상메모리에 대해 설명해주세요**

- 메모리란?
    - 프로그램과 프로그램 수행에 필요한 데이터 및 코드를 저장하는 장치
    - 메모리는 크게 내부 기억장치인 주기억장치와 외부기억장치인 보조 기억장치로 분류됨
        - DRAM, CPU 안에 있는 레지스터와 캐시 등이 전자에 해당
        - SSD, HDD 등이 후자에 해당
- 등장 배경
    - 애플리케이션을 실행하는 데 얼마나 많은 메모리가 필요한지에 집중하지 않고, 대신 애플리케이션을 실행하는 데 최소한 얼만큼의 메모리가 필요한가에 집중해 문제를 해결하고자 함
        - 메모리에 올라가지 않는 나머지는 보조 기억장치에 올려서 실행
            - 이 부분이 가상메모리의 핵심
- 가상 메모리는 메모리가 실제보다 많아보이게 하는 기술
- 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점
    - 빠르고 작은 기억장치(RAM) + 느린 기억장치(디스크)
- 가상메모리 구현을 위해 컴퓨터가 특수 메모리 관리 하드웨어를 갖춰야 함
    - MMU(Memory Management Unit)
        - 가상 주소를 물리 주소로 변환, 메모리를 보호
        - MMU를 사용하면 CPU가 각 메모리에 접근하기 이전에 메모리 주소 번역 작업이 수행됨
            - 메모리를 일일이 가상 주소에서 물리적 주소로 번역하면 작업 부하가 너무 높아짐
            - MMU는 RAM을 여러 부분(페이징)로 나눠 각 페이지를 하나의 독립된 항목으로 처리
            - 페이지 및 주소 번역 정보를 기억하는 작업이 가상 메모리 구현에 있어 결정적인 절차

**메모리 계층구조에 대해 설명해주세요**

- 메모리를 필요에 따라 여러가지 종류로 나누어 두는 것
    - CPU가 메모리에 더 빨리 접근 가능함
    - 레지스터
        - 위치 : CPU 내부
        - 접근속도 : 빠름
        - CPU가 요청을 처리하는데 필요한 데이터를 일시적으로 저장하는 장치
        - 컴퓨터에서 4대 주요 기능(기억, 해석, 연산, 제어)을 관할하는 장치
        - CPU는 자체적으로 데이터를 저장할 방법이 없어 메모리로 직접 데이터를 전송할 수 없음
            - 연산을 위해서 반드시 레지스터를 거쳐야 함
            - 이를 위해 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있음
        - 프로세서에 위치한 고속 메모리, 프로세스가 바로 사용할 수 있는 데이터(소량의 데이터, 처리 중간의 결과 등)를 담고 있는 영역
        - 종류
            - 프로그램 계수기(PC), 누산기(AC), 명령어 레지스터(IR), 상태 레지스터(SR), 메모리 주소 레지스터(MAR), 메모리 버퍼 레지스터(MBR), 입출력 주소 레지스터(I/O AR), 입출력 버퍼 레지스터(I/O BR)
    - 캐시
        - 위치 : CPU 내부
        - 접근속도 : 빠름
        - 데이터나 값을 미리 복사해 놓는 임시 장소
        - 시스템의 효율성을 위해 사용
            - 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래걸릴 경우
            - 값을 다시 계산하는 시간을 절약하고 싶은 경우
        - 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 병목 현상을 완화하기 위한 범용 메모리
        - 종류
            - CPU 캐시
                - L1 캐시, L2 캐시, L3 캐시
            - 디스크 캐시
                - 하드디스크에 내장된 작은 컴퓨터 기능(기능 : 디스크 제어, 외부와의 인터페이스)가 소유한 작은 메모리(디스크에 입출력되는 데이터를 저장하는 작은 메모리)
                    - 일종의 기법(하드디스크와 RAM 사이 존재)
            - 그외
                - 소프트웨어적으로 관리
                    - 페이지 캐시 : 운영체제의 메인 메모리를 하드디스크에 복사해 놓는 캐시(ex 웹캐시)
    - 메모리
        - 위치 : CPU 외부
        - 접근 속도 : 레지스터와 캐시보다 느림
        - 주 기억장치(1차 기억장치)
        - 컴퓨터에서 수치, 명령, 자료 등을 기억하는 컴퓨터 하드웨어 장치
        - 구성
            - RAM(Random Access Memory) : 휘발성 기억 장치
                - 컴퓨터가 빠른 액세스를 하기 위해 데이터를 단기간 저장하는 구성요소
                - 사용자가 요청하는 프로그램이나 문서를 스토리지 디스크에서 메모리로 로드하여 각각의 정보 액세스
                - 전원이 유지되는 동안 CPU의 연산 및 동작에 필요한 모든 내용 저장
                - 전원 종료시 기억된 내용 삭제
                - Random Access : 어느 위치든 똑같은 속도로 접근해 읽고 쓸 수 있다는 의미
            - ROM(Read Only Memory) : 고정 기억 장치
                - 컴퓨터에 지시사항을 영구히 저장하는 비휘발성 메모리
                - 전원 종료 시 기억된 내용 유지
                - 변경 가능성이 희박한 기능 및 부품에 사용
                    - 소프트웨어 : 초기 부팅 관련 부분
                    - 하드웨어 : 프린터 작동에 관여하는 펌웨어 명령 등
    - 하드디스크
        - 위치 : CPU 직접 접근 불가
        - 접근 속도 : 데이터를 메모리로 이동시켜 접근 가능
        - 하드디스크, 하드 드라이브, 고정디스크
        - 비휘발성, 순차접근이 가능한 컴퓨터의 보조기억장치
        - 작동원리
            - 보호 케이스 내부의 플래터 회전
                - 플래터에 자기 패턴으로 정보 기록
                - 플래터 표면의 코팅된 자성체에 데이터 기록
                - 회전하는 플래터 위에 부상하는 입출력 헤드에 의해 자기적으로 데이터 기록 및 조회 가능
        - 구성 요소
            - 제어회로, 스핀들 모터(Spindle Motor), 플래터(Platter), 액추에이터(Actuator), 액추에이터암(Actuator Arm), 헤드(Head)
- 계층 구조의 필요성
    - CPU는 작은 메모리에 더 빨리 접근이 가능
    - 디코딩(명령 해독단계) 속도
        - 복호화
        - CPU는 3개의 버스를 통해 메모리에 접근
            - 주소 전달 버스 : CPU가 메모리의 어느 부분의 데이터를 접근할 지 나타냄
            - 데이터 전달 버스 : 메모리와 CPU 간 데이터 전송
            - 컨트롤 신호 버스 : CPU의 메모리 접근 여부 표시
        - 주소 전달 버스 및 데이터 전달 버스에 값이 존재하고 컨트롤 신호 전송
            - CPU와 메모리 업무 수행
        - 큰 메모리 용량을 사용할 경우 디코딩에 많은 시간 소요됨
            - CPU가 빠르게 데이터에 접근하기 위해서는 데이터를 저장하는 메모리가 작아야 함
    - 자주 쓰는 데이터는 계속 자주 쓰임(참조의 지역성)
        - 큰 메모리를 사용한다고 해도 그 안의 모든 데이터를 고르게 접근하지 않음
        - 자주 쓰는 데이터는 계속 자주 씀
        - 캐시는 메모리보다, 메모리는 하드디스크보다 작아도됨
            - 자주 쓰는 데이터는 전체 데이터에 비해 작은 양
    - 경제성
        - 메모리 구조에서 상층에 속할수록 더 비쌈
        - 메모리 계층 구조의 모양이 피라미드인 이유
            - 비싼 하드웨어는 꼭 필요한 만큼의 크기만 사용
            - 싼 하드웨어를 넉넉한 크기만큼 사용

**동기와 비동기에 대해 설명해 주세요.**

- 동기
    - 데이터의 요청과 결과가 한 자리에서 동시에 일어나는 것
    - 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 함
    - 순서에 맞춰 진행되야함
        - 즉, 여러 요청을 동시에 처리할 수 없음
    - 장점
        - 매우 설계가 간단하고 직관적
    - 단점
        - 결과가 주어질 때까지 아무것도 못하고 대기해야 함
- 비동기
    - 요청 결과는 동시에 일어나지 않을 것
    - 하의 요청에 따른 응답을 즉시 처리하지 않아도, 그 대기 시간동안 또 다른 요청에 대해 처리 가능한 방식
        - 동기 방식보다 속도가 떨어질 수도 있음
    - 장점
        - 동기보다 설계가 복잡함
        - 결과 주어지는데 시간이 걸리더라도 그 시간 동안 작업을 할 수 있으므로 자원을 효율적으로 사용 가능

**세마포어와 뮤텍스의 차이에 대해 설명해주세요.**

- 세마포어와 뮤텍스는 프로세스, 스레드에서 사용되는 일종의 열쇠
- 임계구역
    - 다수의 프로세스가 데이터를 공유하며 실행되는 상황에서 각 프로세스가 공유 자원에 접근하는 코드 블록
        - 다수의 프로세스가 동시에 공유자원에 접근하여 사용하면 문제가 생김
- 세마포어
    - 임계구역에서 발생할 수 있는 문제를 해결하기 위해 등장한 개념
    - 어떤 공유 자원에 대해 동시에 접근할 수 있는 프로세스, 스레드의 수를 변수로 제한
        - 변수는 운영체제나 커널에 실제로 저장되며, 각 프로세스가 이 값을 확인하고 변경할 수 있음
    - 사용 가능한 세마포어 값이 0이면
        - 사용중인 프로세스, 스레드가 사용을 마칠 때 까지 대기
        - 이후 대기중이던 프로세스가 자원 사용
- 뮤텍스
    - 상호 배제(Mutual Exclusion)의 줄임말
    - = 이진 세마포어
        - 세마포어의 특성들을 어느정도 가지고 있지만 차이점이 있음
    - 뮤텍스는 단 하나의 프로세스, 스레드만 접근 가능
        - 뮤텍스가 사용되는 임계 구역은 공유가 불가능한 자원
        - 사용중인 프로세스, 스레드가 락을 걸어 다른 프로세스, 스레드의 접근을 방지함
    - 뮤텍스는 프로세스단에서 관리됨
    - 뮤텍스 락은 본인이 아니면 해제가 불가능
        - 다른 프로세스들도 자유롭게 확인하고 변경 가능했던 세마포어와는 다르게 뮤텍스는 락을 건 프로세스, 스레드 본인이 아니면 해제 불가
    - 과정
        - 제어권 획득
        - Lock 설정
        - 다른 프로세스, 스레드 대기
        - lock 해제
        - 대기중이던 프로세스, 스레드 제어권 획득

**페이징과 세그멘테이션에 대해 설명해주세요**

- 페이징
    - 프로세스의 주소 공간을 페이지란 단위의 고정된 사이즈로 나누어 물리적 메모리에 불연속으로 저장하는 방식
    - 페이징 방식으로 메모리 할당 시 실제 프로세스가 실행될 때는 각각의 페이지들이 실제 메모리의 어디에 위치하고 있는지를 빠르게 알 수 있어야 함
    - 프로세스 입장에선 자신이 사용하고 있는 메모리 공간이 흩어져있는 페이지들이 아니라 하나의 연속된 메모리 공간으로 이해할 수 있어야지 프로그램 실행이 효율적이게 됨
    - 보호
        - 모든 주소는 페이지 테이블을 경유하므로 테이블을 이용해서 보호 기능 수행 가능
    - 공유
        - 메모리 낭비를 방지하기 위함
        - 각각의 프로세스들의 특정 페이지가 실제 물리 메모리에 같은 프레임으로 연결되도록 페이지 테이블 정보를 가지고 있게 된다면 서로 다른 프로세스지만 동일 메모리 사용 가능
    - 한계
        - 내부 단편화(Interner fragment)
            - 페이징 방식으로 외부 단편화 문제는 해결할 수 있지만 내부 단편화는 해결 못함
            - 내부 단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 페이지를 다 채울수 없어 발생하는 공간
                - 메모리 낭비의 원인
            - 페이지 크기가 작으면 내부 단편화가 감소 되긴 하지만 이는 곧 페이지 테이블 크기를 증가시킴
            - 페이징에서는 내부 단편화를 해결할 방법이 없지만, 내부 단편화는 외부 단편화에 비해 낭비되는 메모리 공간이 매우 적음
                - 내부 단편화 최대 낭비 크기는 페이지 사이즈
                - 외부 단편화는 최대 전체의 1/3
- 세그멘테이션
    - 물리적인 고정 크기 분할하는 페이징과 달리 프로그램의 논리적인 내용 단위로 프로세스의 메모리 공간을 분리
    - 논리적 단위로는 method, procedure, function, object, variables, stack 등 함수 단위로 나눌 수 있고 C 컴파일러 관점에서는 코드, 전역 변수, 힙, 스택, 표준 C 라이브러리 단위로 구분지을 수 있음
    - 논리적 내용의 단위(의미가 같은)로 자르기 떄문에 세그먼트들의 크기는 일반적으로 같지 않음
    - 메모리에 할당하는 방법에 대해서는 페이징과 같음
    - 한계
        - 외부 단편화
            - 가변적인 크기를 가져가기 때문에 내부 단편화는 해결 가능하지만, 외부 단편화 문제 발생 가능
- 궁극 적으로 두 기법을 모두 사용해 장점만을 가져와 단편화 문제를 효과적으로 해결할 수 있는 방안을 모색 가능
    - 세그멘테이션은 보호와 공유 면에서 효과적
    - 페이징은 외부 단편화 문제를 해결하는데 효과적
    - 방법
        - 프로세스를 처음에 세그먼트 단위로 자름
        - 의미있는 단위로 나누게 되면 보호와 공유를 하는 측면에서 이점을 가질 수 있음
        - 세그먼트로 인한 외부 단편화 문제를 해결하기 위해 잘라진 세그먼트를 일정 간격인 페이지 단위로 자르는 페이징 방법 사용
        - 이후 메모리에 적재하면 페이징의 일정 단위로 다시 잘렸기 떄문에 외부 단편화 발생 X

**데드락에 대해 설명해주세요**

- 시스템 자원에 대한 요구가 뒤엉킨 상태
    - 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황
- 발생 조건
    - 상호 배제
        - 한 번에 프로세스에 하나만 해당 자원을 사용할 수 있음
            - 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 함
    - 점유 대기
        - 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 함
    - 비선점
        - 이미 할당된 자원을 강제로 빼앗을 수 없음
    - 순환 대기
        - 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 함
- 해결법
    - 예방
        - 데드락의 발생조건 4가지 중 하나라도 발생하지 않도록 하게 함
        - 자원의 상호 배제 조건 방지
            - 한 번에 여러 프로세스가 공유자원을 사용하도록 함
                - 동기화 관련한 문제가 발생할 수 있음
        - 점유 대기 조건 방지
            - 프로세스 실행에 필요한 모든 자원을 한꺼번에 요구하고 허용할 때까지 작업을 보류해 나중에 또 다른 자원을 점유하기 위한 대기 조건을 성립하지 않도록 함
        - 비선점 조건 방지
            - 이미 다른 프로세스에게 할당된 자원이 선점권이 없다고 가정할 떄, 높은 우선 순위의 프로세스가 해당 자원을 선점할 수 있도록 함
        - 순환 대기 조건 방지
            - 자원을 순환 형태로 대기하지 않도록 일정한 한 쪽 방향으로만 자원을 요구할 수 있도록 함
    - 회피
        - 자원 할당 후에도 시스템이 항상 safe state에 있을 수 있도록 할당을 허용
            - 은행원 알고리즘
                - 어떤 자원의 할당을 허용하는지에 관한 여부 결정 전 미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션하여 Safe state에 들 수 있는지 여부 검사
                    - 교착상태 가능성을 미리 조사하는 것
                - 미리 최대 자원 요구량을 알아야 하고, 할당할 수 있는 자원 수가 일정해야 하는 등의 제약 조건 존재
                    - 이에 따라 자원 이용도 하락
            - safe state
                - 프로세스들이 요청하는 모든 자원을 데드락을 발생시키지 않으면서도 차례로 모두에게 할당해 줄 수 있는 상태
                - safe sequence
                    - 특정한 순서로 프로세스들에게 자원을 할당, 실행, 종료 작업을 할 때 데드락이 발생하지 않는 순서
    - 탐지 및 회복
        - 탐지 기법
            - Allocation, Request, Available 등으로 시스템에 데드락이 발생했는지 여부 탐색
                - 은행원 알고리즘과 유사하게 현재 시스템의 자원 할당 상태를 가지고 파악
            - 자원 할당 그래프를 통해 탐지 가능
        - 회복 기법
            - 탐지를 통해 발견했다면 순환 대기에서 벗어나 데드락으로부터 회복하기 위한 방법 사용
                - 단순히 프로세스를 1개 이상 중단
                    - 교착 상태에 빠진 모든 프로세스 중단
                        - 계속 연산중이던 프로세스들도 모두 일시에 중단되어 부분 결과가 폐기될 수 있는 부작용
                    - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하며 회복
                        - 매번 탐지 알고리즘을 호출 및 수행해야 하므로 부담이 되는 작업일 수 있음
                - 자원 선점
                    - 프로세스에 할당된 자원을 선점해 교착상태를 해결할 때까지 그 자원을 다른 프로세스에 할당