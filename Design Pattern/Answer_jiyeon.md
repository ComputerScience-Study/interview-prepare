# 1. 사용해 본 디자인 패턴이 있나요? 있다면 어떤 패턴을 사용했고 왜 사용했나요?

### [답변]

네 빌더 패턴과 MVC패턴을 사용해봤습니다.

당시 프론트엔드와 백엔드 인원 2명이서 프로젝트를 하였으므로 역할 분담의 효율성을 높이기 위해 MVC패턴을 사용하였습니다. 


# 2. MVC, MVP, MVVM 패턴에 대해 각각의 구조와 장단점을 설명해 주세요.

### [답변]

MVC

Model: 데이터와 관련

View: 사용자한테 보여지는 부분 즉 UI, 웹 페이지

Controller: 모델과 뷰를 이어주는 부분

컨트롤러 → 모델에 요청 (모델은 데이터)

컨트롤러 → 뷰 (사용자가 보는 UI에 데이터를 넣어 웹 페이지 보여줌)

장점: 효율성을 높이고 유지보수가 편리해지고, 애플리케이션의 확장성과 유연성이 늘어나고, 중복코딩의 문제점이 사라진다.(유저 인터페이스와 비지니스 로직 분리)

단점: 뷰와 모델 사이의 의존성이 높다.

MVP

장점: 뷰와 모델 사이의 의존성이 없다.

단점: 뷰와 프레젠터의 의존성이 높다. view 하나마다 presenter가 필요

view → presenter 요청

presenter → model 데이터 요청

model → presenter 데이터 응답

presenter → view 데이터 응답

MVVM

view가 vm을 지켜보면서  값이 바뀌는 걸 변경

view → vm 요청

vm→ model 데이터 요청

model → vm데이터 응답

MVC를 지키면서 코딩하는 방법

- 모델은 컨틀롤러와 뷰에 의존하지 않아야 한다.
- 뷰는 모델에만 의존, 컨트롤러에 의존 X
- 뷰가 모델로부터 데이터를 받을 때는, 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야 한다.
- 컨트롤러는 모델과 뷰에 의존 가능
- 뷰가 모델로부터 데이터를 받을 때, 반드시 컨트롤러에서 받아야 한다.


# 3. 생성 패턴 중 Builder Pattern에 대해 설명해주세요.

### [답변]

디자인 패턴 중 생성형에 속하며 객체를 생성할 때 생성자를 직관적으로 사용하기 위해 사용합니다.

setter 일관성에 문제가 생김(객체의 모든 요소가 set 되어야됨)

언제 어디서든 객체의 값 접근과 변경 가능(보안 취약)

생성자는 매개변수가 많아지면(경우에 따라서 변수가 헷갈리면) null값으로 채워야하거나 위치가 헷갈림

빌더를 사용하면 가독성이 높아지고, 필요한 값만 세팅 가능(자동 null)

코드가 길어지는 단점

lombok의 @Builder 는 클래스 위에나 생성자(특정 값만) 위에 써서 사용 가능

GoF 디자인 패턴의 빌더 패턴과 같음

# 4. 싱글톤 패턴에 대해 설명해주세요.

### [답변]

하나의 프로세스에서 객체는 하나만 생성(클레스 인스턴스 하나만 생성)

클래스의 생성자를 private으로 하여 외부에서 해당 클래스의 인스턴스를 직접 생성할 수 없도록 한다.(내부에서 인스턴스 생성 후 반환)

추상화, 캡슐화 적극 활용 가능

상태를 일관적으로 유지 가능

사용되는 경우

- 객체가 리소스를 많이 차지할 경우(비용이 많이 드는 경우)
- 객체가 외부 네트워크랑 연결되어 사용할 경우(단 한개만 있어야 하는 경우)
- 전역 상태 관리

주의사항

- 멀티스레드 환경(동기화)
- 메모리 관리(메모리를 계속 점유하기 때문에)

# 5. 디자인 패턴의 개념과 알고있는 디자인 패턴의 종류를 말해주세요.

### [답변]

디자인 패턴은 과거 개발자들이 유지보수를 효율적으로 하기 위해 규정한 패턴, 규약입니다.

종류로는 크게 생성, 구조, 행위의 목적성으로 나눠지게 되며, 주요 패턴들로는 싱글톤, 빌더 등이 있습니다.

디자인 패턴 생성 과정

코드가 많아짐 → 복잡함 → 수정 어려움, 유지보수 힘듦

이렇게 하면 유지보수가 좀 괜찮더라 → 그 형식들을 논문으로 발표

좋은 코드

- 가독성이 좋음
- 간결함
- 확장과 수정에 용이
- 유지 보수가 편함
- 결합도가 낮음
- 응집도는 높음

# 6. 결합도와 응집도에 대해 설명해주세요.

### [답변]

결합도는 서로 다른 모듈 간에 상호 의존하는 정도를 의미하고, 응집도는 요소들이 서로 관련되어 있는 정도를 뜻합니다.

이 결합도와 응집도에 의해 소프트웨어를 각 기능별로 나눈 모듈의 독립성이 정해집니다. 결합도가 낮고, 응집도가 높을수록 모듈의 독립성은 높아집니다.

# 7. SOLID와 GRASP에 대해 간략히 설명해주세요.

### [답변]

SOLID는 객체 지향 설계 5원칙으로 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙이 있습니다.

### SRP (Single Responsibility) 단일 책임 원칙

- 클래스는 단 한개의 책임을 가져야 함
- 클래스를 변경하는 이유는 단 하나여야 함

### OCP (Open-Closed) 개방-폐쇄 원칙

- 신규 기능 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 함
- 즉, 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야 함

### LSP (Liskov Substitution) 리스코프 치환 원칙

- 하위 타입 객체는 상위 타입 객체에서 가능한 행위를 수행할 수 있어야 함→ 즉, 상위 타입 객체를 하위 타입 객체로 치환해도 정상적으로 동작해야 함

### ISP (Interface Segregation) 인터페이스 분리 원칙

- 클라이언트는 자신이 사용하는 메소드에만 의존해야 한다는 원칙
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 않아야 함→ 하나의 통상적인 인터페이스보다는 차라리 여러 개의 세부적인 (구체적인) 인터페이스가 나음
- 인터페이스는 해당 인터페이스를 사용하는 클라이언트를 기준으로 잘게 분리되어야 함

### DIP (Dependency Inversion) 의존 역전 원칙

- 의존 관계를 맺을 때, 하위개념보다는 상위개념을 의존하여야 함
- 추상화 O, 구체화 X

**정리**

SRP 와 ISP 는 객체가 커지는 것을 막아준다. 객체가 단일 책임을 갖도록 하고 클라이언트마다 특화된 인터페이스를 구현하게 함으로써 한 기능의 변경이 다른 곳까지 미치는 영향을 최소화하고, 이는 기능 추가 및 변경에 용이하도록 만들어 준다.

LSP 와 DIP 는 OCP 를 서포트한다. OCP 는 자주 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장에는 용이하되 기존 코드의 변화에는 보수적이도록 만들어 준다. 여기서 '변화되는 부분을 추상화'할 수 있도록 도와주는 원칙이 DIP 이고, 다형성 구현을 도와주는 원칙이 LSP 인 것이다.

---

GRASP(**G**eneral **R**esponsibility **A**ssignment **S**oftware **P**atterns): 책임 할당sw패턴

객체에 책임을 할당하기위한 지침으로 책임 중심 설계를 위한 원칙들입니다. 

- 컨트롤러: 수행해야 할 작업을 다른 개체에 위임해야 하며, 활동을 조정하거나 통제해야 하지만 컨트롤러 자체가 많은 일을 해서는 안 됩니다.
- 생성자: 다른 객체를 포함하거나 그 일부이거나 사용 및 기록한다면 해당 객체를 생성할 책임이 있습니다.
- 높은 응집력: 응집력이 높다는것은 주어진 요소의 책임이 밀접하게 관련되어 있고 집중되어 있음을 의미합니다.
- 낮은 결합도
    - 클래스간의 종속성이 낮다
    - 한 클래스의 변화가 다른 클래스에 미치는 영향이 낮다.
    - 높은 재사용 가능성
- 정보 전문가: 책임을 할당하는 일반적인 방법은 주어진 책임을 확인하고 그 책임을 이행하는 데 필요한 정보를 결정한 다음 해당 정보가 저장되는 위치를 결정하는 것입니다.???

---

- 우회: 두 객체 사이의 중간 요소에 중재 책임을 할당하여 두 요소 간의 낮은 결합 및 재사용 가능성을 지원합니다. (ex: MVC에서 C)
- 다형성: 유형에 따른 행동의 변경을 정의하는 책임은 이러한 변형이 발생하는 유형에 할당됩니다.
- 보호된 변형?: 변경될 여지가 있는곳에 안정된 인터페이스를 정의하여 사용합니다.
- 순수 제작: 책임이 분산되지않게 해당 책임만 모아 클래스 생성

# 8. 구조 패턴 중 Composite Pattern에 대해 설명해주세요.

### [답변]

컴포지트 패턴은 단일체(오브젝트)와 집합체(그룹)를 하나의 동일한 개념(타입)으로 처리하기 위한 패턴입니다.(같은 인터페이스를 가지고 있다, 상속받았다.)

이는 트리 구조를 나타내기 좋은 형태입니다.

객체의 구조가 복잡할 때 유용하며, 객체 간의 결합도를 낮추어 유연성을 높일 수 있습니다.

트리의 주된 목적은 탐색이며, 의사 결정, 파일 시스템(디렉터리 구조), 검색 엔진, DBMS, 라우터 알고리즘, 계층적 데이터를 다루는 등 매우 다양한 곳에서 응용됩니다.

트리의 구조가 복잡할때 뿌리에서 함수 하나를 콜하면 leaf까지 도달하기 좋다.
