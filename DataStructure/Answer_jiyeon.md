1. Stack의 구조와 개념을 설명하고 Stack의 실사용 예를 설명해주세요.
stack은 삽입과 삭제를 한쪽에서 하는 구조로 후입선출의 특징을 갖습니다.
 이러한 특징으로 인해 재귀 알고리즘, 웹 브라우저 방문 기록(복귀 주소), 실행 취소에 주로 사용됩니다.
    
        👩‍💻 <더 나올 수 있는 질문들>
        Q. 예시로 말하신 동작 흐름에 대해 설명해주세요.
        웹 브라우저 방문 기록로 예를 들자면
        A→B일 경우 다시 A로 돌아가고자 한다면 B를 pop하여 top이 A가 되게하여 이전 페이지로 돌아갑니다. 이건 복귀 주소를 저장하고
        있는 스택의 특징으로 가능한 동작입니다.
    
    [피드백]
    시간 복잡도 설명 좋았음
    
2. HashMap과 Hashtable의 차이점에 대해 설명해주세요.
우선 HashTable은 collection framework가 나오기 이전의 버전으로 HashMap보다 생긴지 오래된 클래스입니다.
그리고 가장 큰 차이는 Thread-safe입니다.
HashTable 같은 경우 동기화를 지원합니다. 그로인해 메소드 호출 전 스레드간 동기화 락을 통해 멀티 스레드 환경에서 data의 무결성을 보장해줍니다.
그렇지만 락과 언락의 대기 시간이 생겨 속도가 느립니다.
반면 HashMap의 경우 동기화를 지원하지 않아 Thread-safe하지 않다는 특징으로 단일 스레드 환경에서 사용하기 좋습니다. 
하나를 더 말씀드리자면 HashMap에서는 key의 null값을 허용하지만 HashTable에서는 그렇지 않습니다.

    [피드백]
    HashTable은 안사용하고 다른 걸 사용한다.

    
    
        👩‍💻 <더 나올 수 있는 질문들>
        Q. 데이터 무결성이 뭔가요?
        데이터가 전송, 저장되고 처리되는 모든 과정에서 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성입니다.
        
        Q. Thread-safe가 뭐죠?
        멀티 스레드 프로그래밍에서 일반적으로 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없음을 뜻합니다.
        보다 엄밀하게는 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바로 나오는 것으로 정의합니다.
        
        Q. 공통점은 뭐죠?
        둘다 key값을 value에 대응시키는 자료구조라는 것입니다.
    
    
    
3. Array와 LinkedList의 차이가 무엇인가요? 각각 가장 큰 특징과 그로 인해 발생하는 장점과 단점에 대해 설명해주세요.
Array는 연속된 메모리 공간에 존재하고 Linked List는 메모리 상에서 떨어져 있는 데이터들이 앞의 데이터와 뒤의 데이터를 기억하는 형태로 존재합니다.
조회 시간 복잡도 O(1), O(N)
삽입 및 삭제 O(1)+O(N), O(N)
데이터 접근을 주로 사용한다면 배열, 수정을 많이 한다면 리스트를 사용하는 것이 효율적입니다.
Array는 컴파일 과정에서 메모리가 할당되는 정적 메모리 할당인 반면 Linked List는 런타임 환경에서 메모리가 할당되는 동적 메모리 할당입니다.
또한 Array는 Stack 영역에 메모리 할당이 되고, Linked List는 Heap 영역에 할당됩니다.

    [피드백]
    왜 시간 복잡도가 그렇게 나왔는지 설명이 필요

4. PriorityQueue의 동작 원리가 어떻게 되나요?
우선순위 큐는 최대 힙을 이용하여 구현합니다.
최대 힙의 동작에 대해 설명드리겠습니다.
<삽입>
우선 원소를 삽입하면 순차적으로 트리에 저장됩니다.
삽입 이후에는 루트 노드까지 거슬러 올라가면서 최대 힙을 구성합니다.
루트 노드가 가장 큰 값을 갖습니다.
<삭제>
삭제를 하면 루트 노드가 가장 큰 값으로 루트 노드가 삭제됩니다.
그러면 가장 마지막 노드가 루트 노드로 오고 다시 값을 비교하여 최대 힙에 맞는 위치를 찾아줍니다. 이때는 루트 노드에서 자식 노드로 비교를 합니다.

    [피드백]
    시간복잡도까지 말하신게 좋았습니다.

5. 그래프와 트리의 차이는 무엇인가요?
    
    
    |  | 그래프 | 트리 |
    | --- | --- | --- |
    | 방향성 | 방향, 무방향 | 방향만 |
    | 사이클 | 순환, 비순환, 자기순환 | 비순환만 |
    | 루트노드 | 루트 개념 없음 | 한 개의 루트 존재 |
    | 부모-자식 | 부모-자식 개념없음 | 1개의 부모노드(루트 제외) |
    | 모델 | 네트워크 모델 | 계층 모델 |
    | 간선 수 | 자유 | N-1개 |
    
    트리는 단방향으로 상하관계가 존재하며 사이클이 발생 조건이 충족하지않지만
    그래프는 부모-자식, 루트 노드 개념이 없으며 단방향, 양방향이 가능하며 사이클이 발생할 수 있습니다.
    
    [피드백]
    두괄식 답변
    
6. B+ tree (균형 이진 트리)의 개념과 구조를 설명해주세요.
탐색에 유리한 균형 이진 트리로 인덱스 노드와 데이터를 저장하는 leaf 노드로 구성되어 있습니다.
leaf 노드가 연결 리스트 형태로 되어있어 탐색 속도가 빠릅니다.(선형 검사)
    
    인덱스 부분의 key값은 leaf에 있는 key값을 직접 찾아가는데 사용합니다.
    7. 이진탐색트리의 최악의 시간복잡도를 말하고, 어떤 경우에 그렇게되는지 말해보세요.
    O(N)입니다.
    한쪽으로 치우쳐져있을때 최악의 경우가 됩니다.
    이진 탐색 트리는 높이가 낮을 수록 성능이 향상됩니다.
    이 경우를 예방하기위해 강제적으로 완전 이진 트리의 구조로 만드는 균형이진트리를 사용합니다.
    
    [피드백]
    특징을 사용해서 왜 그렇게 되었는 지 설명을 풀어가서 좋았다.

8. Red-Black Tree에 대해 설명해주세요.
자가 균형 이진 탐색 트리로 4가지 조건을 통해 균형을 맞춰줍니다.

    [조건]
        
    1. Root Property : 루트노드의 색깔은 검정(Black)이다.
        
    2. External Property : 모든 external node(자식이 없는)들은 검정(Black)이다.
        
    3. Internal Property : 빨강(Red)노드의 자식은 검정(Black)이다.
        
    == No Double Red(빨간색 노드가 연속으로 나올 수 없다.)
        
    4. Depth Property : 모든 리프노드에서 Black Depth는 같다.
        
    == 리프노드에서 루트노드까지 가는 경로에서 만나는 블랙노드의 개수는 같다.
        
    [어려움]
        
    ### Restructuring
    나(z)와 내 부모(v), 내 부모의 부모(Grand Parent)를 오름차순으로 정렬무조건 가운데 있는 값을 부모로 만들고 나머지 둘을 자식으로 만든다.올라간 가운데 있는 값을 검정(Black)으로 만들고 그 두자식들을 빨강(Red)로 만든다.
    
        
    ### Recoloring
    현재 inset된 노드(z)의 부모와 그 형제(w)를 검정(Black)으로 하고 Grand Parent(내 부모의 부모)를 빨강(Red)로 한다.Grand Parent(내 부모의 부모)가 Root node가 아니었을 시 Double Red가 다시 발생 할 수 있다.
    
        
    피드백
    질문 자체가 포괄적이다.
